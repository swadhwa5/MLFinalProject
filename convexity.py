# -*- coding: utf-8 -*-
"""Convexity.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NO_GTIEosYutaDZPaw1ojf32pqHYCqjN
"""

import numpy as np
import skimage
import matplotlib.pyplot as plt
from tempfile import TemporaryFile
from PIL import Image, ImageEnhance
from os import listdir
import imghdr
from skimage.transform import rotate, AffineTransform, warp
from skimage import filters
from torchvision import transforms
import cv2
import scipy
import random
import alphashape
from descartes import PolygonPatch

# def loadImages(path):
#     imagesList = listdir(path)
#     imgs = []
#     labels = []
#     for image in imagesList:
#       if imghdr.what(path + image) == 'png':
#         if (image[len(image) - 13] == '1' and image[6].isalpha()): # only add 5 of each image, only add alphabetical values
#           img = Image.open(path + image)
#           imgs.append(img)
#           labels.append(image[6]) # assumes that filename structure is 'handx_[label]_....'
#     return imgs, labels
def loadImages(path):
    imagesList = listdir(path)
    imgs = []
    labels = []
    for image in imagesList:
      if imghdr.what(path + image) == 'png':
        if (image[6].isalpha()): # only add 5 of each image, only add alphabetical values
          img = Image.open(path + image)
          imgs.append(img)
          labels.append(ord(image[6]) - ord('a')) # assumes that filename structure is 'handx_[label]_....'
    return imgs, labels

# Convert png img array to array np arrays
def ImagesToArray(imgs):
  imgs_array = []
  for img in imgs:
    img_array = np.array(img)
    imgs_array.append(img_array)
  return imgs_array

# Reshape Images   
def shape600(x):
  reshaped_array = np.zeros((len(x), 600, 600, 3))
  for i, img in enumerate(x):
    x_pad_width = (600 - img.shape[0])//2
    y_pad_width = (600 - img.shape[1])//2
    reshaped_array[i,:,:,:] = np.pad(img, ((x_pad_width, x_pad_width + (img.shape[0])%2), (y_pad_width, y_pad_width+(img.shape[1]%2)), (0,0)), constant_values=img[0][0][0])
  return reshaped_array

# Normalize images
def Normalize(imgs):
  new_imgs = []
  for img in imgs:
      # flat_img = img.flatten()
      m = np.mean(img)
      std = np.std(img)
      img = (img-m)/std
      new_imgs.append(img)
  return new_imgs

# x is input image, sd is how much to blur
def blur(imgs, sd=1):
  filtered_img = np.zeros((imgs.shape[0], 600, 600, 3))
  for i in range(imgs.shape[0]):
    filtered_img[i,:,:,:] = skimage.filters.gaussian(imgs[i,:,:,:], sigma=sd)
    #filtered_img.save('./Filter_gaussian/img_' + i + '_gaussianfilt.png')
  return filtered_img

def Scale(imgs):
  scaled_images = np.zeros((len(imgs), 600, 600, 3))
  for i, img in enumerate(imgs):
    # ratio = random.randrange(.2, .5, .1)
    ratio = random.choice([0.1, 0.2, 0.3, 0.4])
    x = int(ratio * 600 / 2)
    scaled = img[x:600-x, x:600-x]
    # scaled = cv2.imread(scaled)
    res = cv2.resize(scaled, dsize=(600, 600), interpolation=cv2.INTER_CUBIC)
    scaled_images[i] = res
  return scaled_images
    # final.save('./Crop/img_' + str(i) + '_scale.png')

def Rotate30(imgs): 
  rot30_imgs = np.empty([imgs.shape[0], imgs.shape[1], imgs.shape[2], imgs.shape[3]])
  for i, img in enumerate(imgs): 
    rand_dir = random.choice([-1, 1])
    new_img = rotate(img, rand_dir * 30) 
    rot30_imgs[i, :] = new_img
  return rot30_imgs

def VerticalFlip(imgs): 
  flip_imgs = np.empty([imgs.shape[0], imgs.shape[1], imgs.shape[2], imgs.shape[3]])
  for i, img in enumerate(imgs): 
    new_img = np.fliplr(img)
    flip_imgs[i, :, :, :] = new_img
  return flip_imgs

def Translation(imgs): 
  trans_imgs = np.empty([imgs.shape[0], imgs.shape[1], imgs.shape[2], imgs.shape[3]])
  for i, img in enumerate(imgs): 
    rand_x = random.randrange(-150, 150, 50)
    rand_y = random.randrange(-150, 150, 50)
    transform = AffineTransform(translation=(rand_x,rand_y))
    new_img = warp(img,transform, mode="constant")  
    trans_imgs[i, :] = new_img
  return trans_imgs

def Augment(imgs_array_before, i):
  # Step 2 Normalize images
  imgs_array_normalize = Normalize(imgs_array_before)

  # Step 3 Reshape the images
  imgs_array_reshaped = shape600(imgs_array_normalize)

  # Step 4 Blur the images
  blurred_imgs = blur(imgs_array_reshaped, 10)

  # Step 5 Scale the images
  scaled_imgs = Scale(imgs_array_reshaped)

  # Step 6 Flip the images
  flipped_imgs = VerticalFlip(imgs_array_reshaped)

  # Step 7 Add translation to images
  translated_imgs = Translation(imgs_array_reshaped)

  # Step 8 Rotate 30 Degrees
  rotated30_imgs = Rotate30(imgs_array_reshaped)

  # Step 10 combine all augmented images to np array of shape((num_augmentations + 1) * num_images, 600, 600, 3)
  final_imgs_temp = np.concatenate((imgs_array_reshaped, blurred_imgs, scaled_imgs, translated_imgs, flipped_imgs, rotated30_imgs), 0)
  print(final_imgs_temp.shape)
  return final_imgs_temp


# final_imgs = np.empty([0, 600, 600, 3])
# n = int(130/65)
# for i in range(n):
#   final_imgs_temp = Augment(imgs_array_before[i * 65:(i + 1) * 65], i)
#   final_imgs = np.concatenate((final_imgs, final_imgs_temp), 0)

# Feature: Get convexity of hand in the image



def convex(imgs):
  convexHull = []
  alphaShape = []
  convexities = []
  cmax = 0
  amax = 0
  for i, img in enumerate(imgs): 
    try:
      orig = cv2.normalize(img, None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8U)
      orig = cv2.resize(orig, (64, 64), interpolation = cv2.INTER_AREA)

      edges = cv2.Canny(orig,250,300)

      contours, _ = cv2.findContours(edges,cv2.RETR_TREE,cv2.CHAIN_APPROX_NONE)
      contours = np.concatenate(contours)
      contours = contours.reshape((contours.shape[0], contours.shape[2]))

      alpha = alphashape.alphashape(contours, .07)
      x, y = alpha.exterior.coords.xy
      alphaPoints = np.column_stack((x, y))

      convex = alphashape.alphashape(contours, 0.)
      x, y = convex.exterior.coords.xy
      convexPoints = np.column_stack((x, y))


      convexities.append(alpha.area / convex.area)
      alphaShape.append(alphaPoints.flatten())
      convexHull.append(convexPoints.flatten())
      
      amax = max(alphaPoints.shape[0] * 2, amax)
      cmax = max(convexPoints.shape[0] * 2, cmax)
    except:
      # out[i] = -1
      alphaShape.append(np.asarray([-1, -1]))
      convexHull.append(np.asarray([-1, -1]))
      convexities.append(-1)
      continue
    # fig, ax = plt.subplots()
    # ax.scatter(*zip(*contours))
    # ax.add_patch(PolygonPatch(alpha, alpha=0.2))
    # # plt.show()

    # fig, ax = plt.subplots()
    # ax.scatter(*zip(*contours))
    # ax.add_patch(PolygonPatch(convex, alpha=0.2))
    # plt.show()

  return convexHull, alphaShape, convexities, cmax, amax

path = "./Only_Mult_Augments/"
# images in an array named imgs
imgs, labels = loadImages(path)
imgs_array_before = ImagesToArray(imgs)
print(len(imgs_array_before))
c, a, convexities, cmax, amax = convex(imgs_array_before)

C = np.empty((len(c), 100))
A = np.empty((len(c), 300))
for i in range(len(c)):
  for j in range(100):
    if (j < c[i].shape[0]):
      C[i][j] = c[i][j]
    else:
      C[i][j] = np.asarray(-1)
  for j in range(300):
    if (j < a[i].shape[0]):
      A[i][j] = a[i][j]
    else:
      A[i][j] = np.asarray(-1)


C = np.asarray(C)
A = np.asarray(A)
convexities = np.asarray(convexities)
print(cmax)
print(amax)
np.save('./aOnlyMult.npy', A)
np.save('./cOnlyMult.npy', C)
np.save('./cvxOnlyMult.npy', convexities)